<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Interactive 4D Tesseract Viewer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        html {
            height: -webkit-fill-available;
        }
        
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100dvh; 
            height: -webkit-fill-available;
            background-color: #111827;
            overflow: hidden;
            box-sizing: border-box;
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
        }
        
        #canvas-container {
            flex-grow: 1;
            width: 100%;
            position: relative;
            min-height: 0;
        }

        #canvas-container > canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        #controls {
            flex-shrink: 0;
            background-color: rgba(31, 41, 55, 0.8);
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(75, 85, 99, 0.5);
            padding: 20px;
            width: 100%;
            box-sizing: border-box;
            position: relative;
            z-index: 10;
            overflow-y: auto;
            max-height: 40vh;
        }
        
        .slider-grid {
            max-width: 800px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 16px;
        }

        @media (min-width: 768px) {
            .slider-grid {
                grid-template-columns: repeat(3, minmax(0, 1fr));
            }
        }

        label {
            color: #d1d5db;
            font-size: 0.875rem;
            display: flex;
            justify-content: space-between;
        }
        
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: #4b5563;
            border-radius: 4px;
            outline: none;
            opacity: 0.9;
            transition: opacity 0.2s;
            touch-action: pan-y; 
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #60a5fa;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid #1f2937;
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #60a5fa;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid #1f2937;
        }
    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="controls">
        <div class="slider-grid">
            <!-- 3D Rotations -->
            <div>
                <label for="xy-slider">
                    <span>XY Rotation</span>
                    <span id="xy-value">0°</span>
                </label>
                <input id="xy-slider" type="range" min="-3.14159" max="3.14159" value="0" step="0.01">
            </div>
            <div>
                <label for="xz-slider">
                    <span>XZ Rotation</span>
                    <span id="xz-value">0°</span>
                </label>
                <input id="xz-slider" type="range" min="-3.14159" max="3.14159" value="0" step="0.01">
            </div>
            <div>
                <label for="yz-slider">
                    <span>YZ Rotation</span>
                    <span id="yz-value">0°</span>
                </label>
                <input id="yz-slider" type="range" min="-3.14159" max="3.14159" value="0" step="0.01">
            </div>
            
            <!-- 4D "Hyper" Rotations -->
            <div>
                <label for="xw-slider">
                    <span>XW Rotation</span>
                    <span id="xw-value">0°</span>
                </label>
                <input id="xw-slider" type="range" min="-3.14159" max="3.14159" value="0" step="0.01">
            </div>
            <div>
                <label for="yw-slider">
                    <span>YW Rotation</span>
                    <span id="yw-value">0°</span>
                </label>
                <input id="yw-slider" type="range" min="-3.14159" max="3.14159" value="0" step="0.01">
            </div>
            <div>
                <label for="zw-slider">
                    <span>ZW Rotation</span>
                    <span id="zw-value">0°</span>
                </label>
                <input id="zw-slider" type="range" min="-3.14159" max="3.14159" value="0" step="0.01">
            </div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.166.1/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.166.1/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let tesseractGroup, lineSegments;
        
        const canvasContainer = document.getElementById('canvas-container');

        // 4D vertices
        const vertices4D = [];
        for (let i = 0; i < 16; i++) {
            vertices4D.push(new THREE.Vector4(
                (i & 1) ? 1 : -1,
                (i & 2) ? 1 : -1,
                (i & 4) ? 1 : -1,
                (i & 8) ? 1 : -1
            ));
        }

        // 32 edges
        const edges = [];
        for (let i = 0; i < 16; i++) {
            for (let j = i + 1; j < 16; j++) {
                let diff = 0;
                if (vertices4D[i].x !== vertices4D[j].x) diff++;
                if (vertices4D[i].y !== vertices4D[j].y) diff++;
                if (vertices4D[i].z !== vertices4D[j].z) diff++;
                if (vertices4D[i].w !== vertices4D[j].w) diff++;
                
                if (diff === 1) {
                    edges.push(i, j);
                }
            }
        }

        let projectedVertices3D = new Float32Array(16 * 3);

        // --- MODIFIED ---
        // We now have two sets of angles:
        // 1. userAngles: Controlled by the sliders.
        // 2. ambientAngles: Increment automatically every frame.
        
        let userAngles = {
            xy: 0, xz: 0, yz: 0,
            xw: 0, yw: 0, zw: 0
        };
        
        let ambientAngles = {
            xy: 0, xz: 0, yz: 0,
            xw: 0, yw: 0, zw: 0
        };
        
        // Define the slow ambient rotation speeds
        const ambientSpeedXY = 0.001;
        const ambientSpeedZW = 0.002;

        // Get sliders and value displays
        const sliders = {
            xy: { slider: document.getElementById('xy-slider'), value: document.getElementById('xy-value') },
            xz: { slider: document.getElementById('xz-slider'), value: document.getElementById('xz-value') },
            yz: { slider: document.getElementById('yz-slider'), value: document.getElementById('yz-value') },
            xw: { slider: document.getElementById('xw-slider'), value: document.getElementById('xw-value') },
            yw: { slider: document.getElementById('yw-slider'), value: document.getElementById('yw-value') },
            zw: { slider: document.getElementById('zw-slider'), value: document.getElementById('zw-value') }
        };

        // --- 4D Rotation Functions ---
        function rotateXY(v, angle) {
            const cos = Math.cos(angle), sin = Math.sin(angle);
            const x = v.x * cos - v.y * sin;
            const y = v.x * sin + v.y * cos;
            return new THREE.Vector4(x, y, v.z, v.w);
        }
        function rotateXZ(v, angle) {
            const cos = Math.cos(angle), sin = Math.sin(angle);
            const x = v.x * cos - v.z * sin;
            const z = v.x * sin + v.z * cos;
            return new THREE.Vector4(x, v.y, z, v.w);
        }
        function rotateYZ(v, angle) {
            const cos = Math.cos(angle), sin = Math.sin(angle);
            const y = v.y * cos - v.z * sin;
            const z = v.y * sin + v.z * cos;
            return new THREE.Vector4(v.x, y, z, v.w);
        }
        function rotateXW(v, angle) {
            const cos = Math.cos(angle), sin = Math.sin(angle);
            const x = v.x * cos - v.w * sin;
            const w = v.x * sin + v.w * cos;
            return new THREE.Vector4(x, v.y, v.z, w);
        }
        function rotateYW(v, angle) {
            const cos = Math.cos(angle), sin = Math.sin(angle);
            const y = v.y * cos - v.w * sin;
            const w = v.y * sin + v.w * cos;
            return new THREE.Vector4(v.x, y, v.z, w);
        }
        function rotateZW(v, angle) {
            const cos = Math.cos(angle), sin = Math.sin(angle);
            const z = v.z * cos - v.w * sin;
            const w = v.z * sin + v.w * cos;
            return new THREE.Vector4(v.x, v.y, z, w);
        }

        // --- 4D to 3D Projection ---
        function project4Dto3D(v) {
            const distance = 4;
            const w_perspective = distance / (distance - v.w + 0.0001); 
            return new THREE.Vector3(
                v.x * w_perspective,
                v.y * w_perspective,
                v.z * w_perspective
            );
        }

        // --- Main Functions ---
        function init() {
            scene = new THREE.Scene();
            
            const width = canvasContainer.clientWidth;
            const height = canvasContainer.clientHeight;

            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(width, height);
            renderer.setPixelRatio(window.devicePixelRatio);
            canvasContainer.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.enableZoom = true;
            controls.enablePan = true; 

            // Tesseract Geometry
            tesseractGroup = new THREE.Group();
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(projectedVertices3D, 3));
            geometry.setIndex(edges);
            const material = new THREE.LineBasicMaterial({
                color: 0x60a5fa,
                linewidth: 2
            });
            lineSegments = new THREE.LineSegments(geometry, material);
            tesseractGroup.add(lineSegments);
            scene.add(tesseractGroup);

            // --- Event Listeners ---
            // Loop through all sliders and attach listeners
            for (const key of Object.keys(sliders)) {
                sliders[key].slider.addEventListener('input', (e) => {
                    // When user moves a slider, update the userAngles
                    const newAngle = parseFloat(e.target.value);
                    userAngles[key] = newAngle; 
                    sliders[key].value.textContent = `${(newAngle * 180 / Math.PI).toFixed(0)}°`;
                });
            }

            window.addEventListener('resize', onWindowResize);
            onWindowResize(); // Call once on init
        }
        
        function onWindowResize() {
            if (!canvasContainer) return;
            const width = canvasContainer.clientWidth;
            const height = canvasContainer.clientHeight;
            if (height === 0) return; 
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        }

        function updateTesseract() {
            // --- MODIFIED ---
            // Add ambient rotation every frame
            ambientAngles.xy += ambientSpeedXY;
            ambientAngles.zw += ambientSpeedZW;
            
            const positions = lineSegments.geometry.attributes.position.array;
            
            for (let i = 0; i < 16; i++) {
                let v = vertices4D[i].clone();
                
                // --- MODIFIED ---
                // Apply the SUM of user angle + ambient angle
                v = rotateXY(v, userAngles.xy + ambientAngles.xy);
                v = rotateXZ(v, userAngles.xz + ambientAngles.xz);
                v = rotateYZ(v, userAngles.yz + ambientAngles.yz);
                v = rotateXW(v, userAngles.xw + ambientAngles.xw);
                v = rotateYW(v, userAngles.yw + ambientAngles.yw);
                v = rotateZW(v, userAngles.zw + ambientAngles.zw);
                
                const v3D = project4Dto3D(v);
                
                positions[i * 3 + 0] = v3D.x;
                positions[i * 3 + 1] = v3D.y;
                positions[i * 3 + 2] = v3D.z;
            }
            
            lineSegments.geometry.attributes.position.needsUpdate = true;
        }

        function animate() {
            requestAnimationFrame(animate);
            updateTesseract(); // This now includes the ambient rotation
            controls.update();
            renderer.render(scene, camera);
        }

        // Start
        init();
        animate();

    </script>
</body>
</html>

